<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.7.2" />
<title>nvx.device API documentation</title>
<meta name="description" content="NVX hardware device representation." />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>nvx.device</code></h1>
</header>
<section id="section-intro">
<p>NVX hardware device representation.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;NVX hardware device representation.&#34;&#34;&#34;
import ctypes
from threading import Thread
import time
import math

from .structs import Version, Settings, Property, DataStatus, ErrorStatus, Gain, PowerSave, \
    ImpedanceSetup, ImpedanceMode, ScanFreq, ImpedanceSettings, Voltages, FrequencyBandwidth, Pll, Rate
from .base import raw, get_count
from .utility import handle_error
from .sample import Sample
from .ring_buffer import RingBuffer
from .impedance import Impedance
from .trigger_states_view import TriggerStatesView
from .channel_states_view import ChannelStatesView


class Device:
    def __init__(self, index: int, buffer_time: float = 1.0):
        &#34;&#34;&#34;A representation of a physical device connected to the system.
        Constructor opens a hardware device for work.
        Device is closed automatically when the object is deleted.

        Parameters
        ----------
        index : int
            device index in the system. Must be in range [0, nvx.get_count())
        buffer_time
            amount of time for which the samples will be kept in seconds
        &#34;&#34;&#34;
        # Opening device -----------------------------------------------------------------------------------------------
        if 0 &lt;= index &lt; get_count():
            self.device_handle = raw.NVXOpen(index)
        else:
            raise ValueError(
                &#34;no device with index &#34; + str(index) + &#34; (only &#34; + str(get_count()) + &#34; devices detected)&#34;)

        if self.device_handle == 0:
            raise RuntimeError(&#34;Could not create a device: NVXOpen returned NULL&#34;)

        # This getter has side effects that are required for the device to work properly
        self.voltages

        # Data collecting ----------------------------------------------------------------------------------------------
        self._buffer_time = buffer_time
        self._buffer = None  # Created at start()
        self._collector_thread = Thread(target=self._collect)
        self._delay_tolerance = 0.01

        # Member variables ---------------------------------------------------------------------------------------------
        self._index = index
        self._is_running = False  # Not for external use. Use start(), stop(), or is_running property instead.
        self._active_shield_gain = 100

        # Data acquisition rate (hz). Not always the same as source_rate property.
        # Not for external use. Use rate property instead.
        self._rate = 10000

        # Set source rate to the maximum. Seems that this results in the least delay. Unneeded samples are discarded
        # during collection.
        s = self._settings
        s.rate = Rate.KHZ_100
        self._settings = s

    @property
    def index(self):
        &#34;&#34;&#34;Device&#39;s index in the system.&#34;&#34;&#34;
        return self._index

    @property
    def is_running(self):
        &#34;&#34;&#34;State of the data acquisition process.&#34;&#34;&#34;
        return self._is_running

    @property
    def version(self):
        &#34;&#34;&#34;Version info about NVX.

        Returns
        -------
        nvx.structs.Version
            NVX version info. See nvx.structs
        &#34;&#34;&#34;
        ver = Version()
        handle_error(raw.NVXGetVersion(self.device_handle, ctypes.byref(ver)))
        return ver

    # Settings and their properties ====================================================================================
    @property
    def _settings(self):
        &#34;&#34;&#34;Device acquisition settings.
        This property is for internal use. Struct Settings has 4 members, (mode, rate, adc_filter, decimation), of which
        mode, rate and decimation can be accessed via their own properties (acquisition_mode, rate/source_rate and
        decimation), and adc_filter is deprecated in the dll.

        Returns
        -------
        nvx.structs.Settings
            device settings. See nvx.structs
        &#34;&#34;&#34;
        result = Settings()
        handle_error(raw.NVXGetSettings(self.device_handle, ctypes.byref(result)))
        return result

    @_settings.setter
    def _settings(self, value):
        &#34;&#34;&#34;Set device acquisition settings
        This property is for internal use. Struct Settings has 4 members, (mode, rate, adc_filter, decimation), of which
        mode, rate and decimation can be accessed via their own properties (acquisition_mode, rate/source_rate and
        decimation), and adc_filter is deprecated in the DLL.

        Rate property affects nvx.structs.Property.rate as well as nvx.structs.Settings.rate.
        
        Parameters
        ----------
        value : nvx.structs.Settings
        &#34;&#34;&#34;
        handle_error(raw.NVXSetSettings(self.device_handle, ctypes.byref(value)))

    @property
    def acquisition_mode(self):
        return self._settings.mode

    @acquisition_mode.setter
    def acquisition_mode(self, value):
        s = self._settings
        s.mode = value
        self._settings = s

    @property
    def decimation(self):
        return self._settings.mode

    @decimation.setter
    def decimation(self, value):
        s = self._settings
        s.decimation = value
        self._settings = s

    # Properties and their properties ==================================================================================
    @property
    def _properties(self):
        &#34;&#34;&#34;Get device acquisition _properties.

        Returns
        -------
        nvx.structs.Property
            device property. See nvx.structs
        &#34;&#34;&#34;
        prop = Property()
        handle_error(raw.NVXGetProperty(self.device_handle, ctypes.byref(prop)))
        return prop

    @property
    def eeg_count(self):
        &#34;&#34;&#34;Get the count of EEG channels.&#34;&#34;&#34;
        return self._properties.count_eeg

    @property
    def aux_count(self):
        &#34;&#34;&#34;Get the count of AUX channels.&#34;&#34;&#34;
        return self._properties.count_aux

    @property
    def input_triggers_count(self):
        &#34;&#34;&#34;Get the count of input triggers.&#34;&#34;&#34;
        return self._properties.triggers_in

    @property
    def output_triggers_count(self):
        &#34;&#34;&#34;Get the count of output triggers.&#34;&#34;&#34;
        return self._properties.triggers_out

    @property
    def source_rate(self):
        &#34;&#34;&#34;Get device&#39;s actual pull rate.
        self._properties.rate is always the same as self._settings.rate, but presented as a float instead of enum.

        Returns
        -------
        int
            device&#39;s internal pull rate. Always one of (10000, 50000, 100000). Default is 10000.
        &#34;&#34;&#34;
        return int(self._properties.rate)

    @property
    def eeg_resolution(self):
        &#34;&#34;&#34;Get the EEG amplitude scale coefficients, in V/bit.

        Returns
        -------
        float
        &#34;&#34;&#34;
        return self._properties.resolution_eeg

    @property
    def aux_resolution(self):
        &#34;&#34;&#34;Get the AUX amplitude scale coefficients, in V/bit.

        Returns
        -------
        float
        &#34;&#34;&#34;
        return self._properties.resolution_aux

    @property
    def eeg_range(self):
        &#34;&#34;&#34;Get the EEG input range peak-peak, in V.

        Returns
        -------
        float
        &#34;&#34;&#34;
        return self._properties.range_eeg

    @property
    def aux_range(self):
        &#34;&#34;&#34;Get the AUX input range peak-peak, in V.

        Returns
        -------
        float
        &#34;&#34;&#34;
        return self._properties.range_aux

    # Adjusted rate property ===========================================================================================
    @property
    def rate(self):
        &#34;&#34;&#34;Device&#39;s pull rate.
        This is the rate at which the device will output values, and is equal to source_rate by default.
        Otherwise, it is usually lower, and some samples will be discarded to meet this rate.

        Returns
        -------
        int
            device&#39;s sample output rate in range [1, 100000] (samples/s).
        &#34;&#34;&#34;
        return self._rate

    @rate.setter
    def rate(self, value):
        &#34;&#34;&#34;Set device&#39;s pull rate.

        Parameters
        ----------
        value : int
            device&#39;s sample output rate in range [1, 100000] (samples/s).
        &#34;&#34;&#34;
        if value &lt;= 0:
            raise ValueError(&#34;sampling frequency too low: must not be less than 1, got &#34; + str(value))
        elif value &gt; 100000:
            raise ValueError(&#34;sampling frequency too high: must not be more than 100000, got &#34; + str(value))

        # Set sampling frequency
        self._rate = value

    # ==================================================================================================================

    def _new_buffer(self):
        &#34;&#34;&#34;Create a new internal buffer.
        Not recommended for external use.
        &#34;&#34;&#34;
        return RingBuffer(math.ceil(self.rate * self._buffer_time), dtype=object)

    def start(self):
        &#34;&#34;&#34;Start data acquisition.
        If data acquisition was already running, does nothing.
        &#34;&#34;&#34;
        if not self.is_running:
            self._buffer = self._new_buffer()
            handle_error(raw.NVXStart(self.device_handle))
            self._is_running = True
            self._collector_thread.start()

    def stop(self):
        &#34;&#34;&#34;Stop data acquisition.
        If data acquisition was not running, does nothing.
        &#34;&#34;&#34;
        if self.is_running:
            self._is_running = False
            self._collector_thread.join()
            handle_error(raw.NVXStop(self.device_handle))

    @property
    def delay_tolerance(self):
        &#34;&#34;&#34;Get device&#39;s delay tolerance.
        Delay tolerance represents time in seconds, how much the device is allowed to wait before attempting to pull a
        data sample. Even with this time, the collector thread will sleep only when it has collected all the samples
        that were available.

        Default time is 0.01 seconds, and can be set to 0 (although that might lead to inconsistent pull times due to
        thread locks fighting).

        Returns
        -------
        float
            Delay tolerance, seconds.
        &#34;&#34;&#34;
        return self._delay_tolerance

    @delay_tolerance.setter
    def delay_tolerance(self, value):
        &#34;&#34;&#34;Set a new delay tolerance.
        Delay tolerance represents time in seconds, how much the device is allowed to wait before attempting to pull a
        data sample. Even with this time, the collector thread will sleep only when it has collected all the samples
        that were available.

        Default time is 0.01 seconds. Delay tolerance is used in the collector thread, and thus cannot be set when the
        device is running.

        Warnings
        --------
        Setting delay_tolerance to 0 might lead to inconsistent pull times.

        Parameters
        ----------
        value : float
            Delay tolerance in seconds (must be not less than 0).

        Raises
        ------
        ValueError
            If the passed value is less than 0.
        RuntimeError
            If the device is currently running.
        &#34;&#34;&#34;
        if value &lt; 0:
            raise ValueError(&#34;delay_tolerance cannot be less than 0&#34;)

        if self.is_running:
            raise RuntimeError(&#34;delay_tolerance cannot be set when the device is running&#34;)
        self._delay_tolerance = value

    def _get_data(self):
        &#34;&#34;&#34;Get acquisition data.
        Returns a data sample or None, if there are no more samples generated.
        Not recommended for external use. Consider using Device.pull_chunk method instead.

        When the device is running, this class calls this function until there are no more samples to get.
        Otherwise, the internal buffer may overflow.

        Returns
        -------
        nvx.sample.Sample or None
            possible data sample. See sample.py
        &#34;&#34;&#34;
        buffer_size_bytes = self.eeg_count * 4 + self.aux_count * 4 + 8
        buffer = ctypes.cast(ctypes.create_string_buffer(buffer_size_bytes), ctypes.c_void_p)

        ret = raw.NVXGetData(self.device_handle, buffer, buffer_size_bytes)
        handle_error(ret)
        if ret == 0:  # no more data to return
            return None

        return Sample(buffer, self.eeg_count, self.aux_count)

    def _collect(self):
        &#34;&#34;&#34;Collect and process samples when running.
        Not recommended for external use.
        &#34;&#34;&#34;
        while self.is_running:
            # Get new sample (returns None if no samples left)
            sample = self._get_data()

            if sample is not None and self._process(sample):
                self._buffer.append(sample)
            if sample is None and self.delay_tolerance &gt; 0:
                time.sleep(self.delay_tolerance)

    def _process(self, sample):
        &#34;&#34;&#34;Process a sample (figure out if it should be discarded to keep user-specified rate).
        Returns True if a sample is to be accepted.
        Not recommended for external use.
        &#34;&#34;&#34;
        ratio = self.rate / self.source_rate

        cup0 = int(ratio * sample.counter)
        cup1 = int(ratio * (sample.counter+1))

        # if a cup was filled, accept sample
        return cup0 != cup1

    def pull_chunk(self):
        &#34;&#34;&#34;Pull all samples from the device.

        Returns
        -------
        nvx.ring_buffer.RingBuffer
            Requested samples. list can be empty, if no samples were generated since last call.
        &#34;&#34;&#34;
        # TODO: is this actually thread-safe?
        result, self._buffer = self._buffer, self._new_buffer()
        return result

    @property
    def _data_status(self):
        &#34;&#34;&#34;Get device acquisition data status.

        Returns
        -------
        nvx.structs.DataStatus
            device data status. See nvx.structs
        &#34;&#34;&#34;
        status = DataStatus()
        handle_error(raw.NVXGetDataStatus(self.device_handle, ctypes.byref(status)))
        return status

    @property
    def error_status(self):
        &#34;&#34;&#34;Get device acquisition error status.

        Returns
        -------
        nvx.structs.ErrorStatus
            device error status. See nvx.structs
        &#34;&#34;&#34;
        status = ErrorStatus()
        handle_error(raw.NVXGetErrorStatus(self.device_handle, ctypes.byref(status)))
        return status

    @property
    def source_sample_count(self):
        &#34;&#34;&#34;Returns how many samples were generated on the hardware device.
        Since Device implements rate downsampling, this number is equal or larger than the amount of samples passed to
        the device user.
        This value is the same as field &#39;samples&#39; in data_status and error status, and provided here for convenience.

        Returns
        -------
        int
            Samples count.
        &#34;&#34;&#34;
        return self._data_status.samples

    @property
    def trigger_states(self):
        &#34;&#34;&#34;Provides a view into device&#39;s trigger states

        Returns
        -------
        TriggerStatesView
            Triggers&#39; view. See trigger_states_view.py
        &#34;&#34;&#34;
        return TriggerStatesView(self)

    @property
    def aux_gain(self):
        &#34;&#34;&#34;Get AUX gain.
        While internally Gain is used as an enum, this function returns an int for convenience.

        Returns
        -------
        int
            gain value (1 or 5).

        See Also
        --------
        nvx.structs.Gain
        &#34;&#34;&#34;
        gain = Gain()
        handle_error(raw.NVXGetAuxGain(self.device_handle, ctypes.byref(gain)))

        if gain == Gain.GAIN_1:
            return 1
        return 5

    @aux_gain.setter
    def aux_gain(self, value):
        &#34;&#34;&#34;Set AUX gain.
        While internally Gain is used as an enum, this function accepts an int for convenience. That means that the only
        acceptable values for gain are 1 and 5.

        Raises
        ------
        ValueError
            if passed gain value is not 1 or 5.

        Parameters
        ----------
        value : int
            gain value.

        See Also
        --------
        nvx.structs.Gain
        &#34;&#34;&#34;
        gain = Gain()
        if value == 1:
            gain = Gain.GAIN_1
        elif value == 5:
            gain = Gain.GAIN_5
        else:
            raise ValueError(&#34;expected a gain value of either 1 or 5, got &#34; + str(value))
        handle_error(raw.NVXSetAuxGain(self.device_handle, gain))

    @property
    def power_save(self):
        &#34;&#34;&#34;Get power save mode.

        Returns
        -------
        bool
            True if power save mode is enabled, False otherwise.
        &#34;&#34;&#34;
        ps = PowerSave()
        handle_error(raw.NVXGetPowerSave(self.device_handle, ctypes.byref(ps)))
        if ps == PowerSave.DISABLE:
            return False
        return True

    @power_save.setter
    def power_save(self, value):
        &#34;&#34;&#34;Set power save mode.

        Parameters
        ----------
        value : bool
            True to enable power save, False to disable.
        &#34;&#34;&#34;
        ps = PowerSave.DISABLE
        if value:
            ps = PowerSave.ENABLE

        handle_error(raw.NVXSetPowerSave(self.device_handle, PowerSave(ps)))

    @property
    def impedance_data(self):
        &#34;&#34;&#34;Get impedance values for all EEG channels and ground in Ohm
        
        Notes
        -----
        - ~750 ms is required for measure impedance per 32 electrodes;
        - max impedance value ~ 300-500 kOhm;
        - impedance measure from 0 Ohm to 120 kOhm with accuracy +/- 15%;
        - works only in impedance mode;
        - ground electrode must be connected for impedance measure;
        - REF electrode (1-st electrode on 1-st module) must be connected for impedance measure;
        - if electrode is not connected, Impedance object will return None.
        
        Returns
        -------
        nvx.impedance.Impedance
            channels impedance. See nvx.impedance
        &#34;&#34;&#34;
        buffer_size = self.eeg_count + 1
        buffer_size_bytes = buffer_size * 4
        buffer = (ctypes.c_uint * buffer_size)()

        handle_error(raw.NVXImpedanceGetData(self.device_handle, buffer, buffer_size_bytes))

        return Impedance(buffer, self.eeg_count)

    @property
    def impedance_setup(self):
        &#34;&#34;&#34;Get setup for impedance mode.

        Returns
        -------
        nvx.structs.ImpedanceSetup
            impedance setup. See nvx.structs
        &#34;&#34;&#34;
        setup = ImpedanceSetup()
        handle_error(raw.NVXImpedanceGetSetup(self.device_handle, ctypes.byref(setup)))
        return setup

    @impedance_setup.setter
    def impedance_setup(self, setup):
        &#34;&#34;&#34;Set setup for impedance mode.

        Parameters
        ----------
        setup : nvx.structs.ImpedanceSetup
            impedance setup. See nvx.structs
        &#34;&#34;&#34;
        handle_error(raw.NVXImpedanceSetSetup(self.device_handle, ctypes.byref(setup)))

    @property
    def impedance_mode(self):
        &#34;&#34;&#34;Get current impedance mode.

        Returns
        -------
        nvx.structs.ImpedanceMode
            impedance mode. See nvx.structs
        &#34;&#34;&#34;
        impedance_mode = ImpedanceMode()
        handle_error(raw.NVXImpedanceGetMode(self.device_handle, ctypes.byref(impedance_mode)))
        return impedance_mode

    @impedance_mode.setter
    def impedance_mode(self, mode):
        &#34;&#34;&#34;Set current impedance mode.

        Parameters
        ----------
        mode : nvx.structs.ImpedanceMode
            impedance mode. See nvx.structs
        &#34;&#34;&#34;
        handle_error(raw.NVXImpedanceGetMode(self.device_handle, ctypes.byref(mode)))

    def set_electrodes(self, values):
        &#34;&#34;&#34;Directly set (control) electrodes states (LEDs and analog switches) in all modes.
        
        Notes
        -----
        - by calling this function, direct control of electrodes starts automatically;
        - to disable direct control of electrodes call set_electrodes_auto;
        - currently, you need to set all electrodes states at once;
        - To set electrodes colors it&#39;s recommended to use NVX_EL_LED_XXX (see globals.py) values.
        
        Parameters
        ----------
        values : a list-like container of objects, each convertible to ctypes.c_uint
            example - a list of int
        
        Warnings
        --------
        - During data acquisition due to switching supply current (i.e. LEDs), a ripple in analog power supply voltage
        appears. This leads to crosstalk to low level input signal and to distortion (and some pulsation) after
        switching supply current (i.e. LEDs);
        - in Impedance mode input analog switch is not accessible;
        - in Impedance mode it is not recommended to call this function very frequently;
        (&gt; few times per 1 sec) or to change (from previous state) too many electrodes, 
        because this will significantly increase impedance measure time (cycle) - see below;
        - After a successful call to this function the device will execute this command:
        ~ 50 ms per 32 electrodes states changes from previous state
        &#34;&#34;&#34;
        buffer_size = self.eeg_count + 1
        buffer_size_bytes = buffer_size * 4
        buffer = (ctypes.c_uint * buffer_size)()

        for i in range(0, buffer_size):
            buffer[i] = ctypes.c_uint(values[i])

        handle_error(raw.NVXSetElectrodes(self.device_handle, buffer, buffer_size_bytes))

    def set_electrodes_auto(self):
        &#34;&#34;&#34;Enable automatic LED control.
        If automatic LED control was disabled by the Device.set_electrodes function, it can be restored by calling this.
        &#34;&#34;&#34;
        handle_error(raw.NVXSetElectrodes(self.device_handle, None, 0))

    @property
    def impedance_scan_frequency(self):
        &#34;&#34;&#34;Get the impedance scanning frequency, in Hz.
        While internally frequency is used as an enum (nvx.structs.ScanFreq) packaged in
        a struct (nvx.structs.ImpedanceSettings), this function returns an int for convenience.

        Returns
        -------
        int
            Impedance scan frequency value (30 or 80 Hz). See also nvx.structs.ScanFreq
        &#34;&#34;&#34;
        imp_settings = ImpedanceSettings()
        handle_error(raw.NVXImpedanceGetSettings(self.device_handle, ctypes.byref(imp_settings)))
        scan_freq = imp_settings.scan_freq

        if scan_freq == ScanFreq.HZ_30:
            return 30
        return 80

    @impedance_scan_frequency.setter
    def impedance_scan_frequency(self, value):
        &#34;&#34;&#34;Set the impedance scanning frequency.
        While internally frequency is used as an enum (nvx.structs.ScanFreq) packaged in
        a struct (nvx.structs.ImpedanceSettings), this function accepts an int for convenience.

        Raises
        ------
        ValueError
            If passed gain value is not 30 or 80.

        Parameters
        ----------
        value : int
            Impedance scan frequency value value. See also nvx.structs.ScanFreq
        &#34;&#34;&#34;
        imp_settings = ImpedanceSettings()
        if value == 30:
            imp_settings.scan_freq = ScanFreq.HZ_30
        elif value == 80:
            imp_settings.scan_freq = ScanFreq.HZ_80
        else:
            raise ValueError(&#34;expected a frequency value of either 30 or 80, got &#34; + str(value))
        handle_error(raw.NVXImpedanceSetSettings(self.device_handle, ctypes.byref(imp_settings)))

    @property
    def voltages(self):
        &#34;&#34;&#34;Get voltages.

        Returns
        -------
        nvx.structs.Voltages
            voltages. See nvx.structs
        &#34;&#34;&#34;
        voltages = Voltages()
        handle_error(raw.NVXGetVoltages(self.device_handle, ctypes.byref(voltages)))
        return voltages

    @property
    def active_shield_gain(self):
        &#34;&#34;&#34;Get gain in ActiveShield mode.

        Returns
        -------
        int
            Gain value
        &#34;&#34;&#34;
        return self._active_shield_gain

    @active_shield_gain.setter
    def active_shield_gain(self, gain):
        &#34;&#34;&#34;Set gain in ActiveShield mode.
        
        Parameters
        ----------
        gain : int
            Impedance settings in range [1, 100]. Default gain is 100.
            
        Raises
        ------
        ValueError
            If gain is not in range [1, 100].
        &#34;&#34;&#34;
        if not 1 &lt;= gain &lt;= 100:
            raise ValueError(&#34;gain must be in range [1, 100], got &#34; + str(gain))

        handle_error(raw.NVXSetActiveShieldGain(self.device_handle, ctypes.c_uint(gain)))
        self._active_shield_gain = gain

    @property
    def polarization(self):
        &#34;&#34;&#34;Get polarization of the electrodes.

        Returns
        -------
        list of float
            Polarisation of electrodes.
        &#34;&#34;&#34;
        # TODO: ask how many electrodes there are (assuming self.eeg_count + GND)
        buffer_size = self.eeg_count + 1
        buffer_size_bytes = buffer_size * ctypes.sizeof(ctypes.c_double)
        buffer = (ctypes.c_double * buffer_size)()

        handle_error(raw.NVXSetElectrodes(self.device_handle, buffer, buffer_size_bytes))

        # Convert to a list of floats
        result = []
        for i in range(0, buffer_size):
            result.append(float(buffer[i]))

        return result

    @property
    def sample_rate_count(self):
        &#34;&#34;&#34;Get device sample rate count.

        Returns
        -------
        int
            Sample rate count.
        &#34;&#34;&#34;
        count = ctypes.c_uint()
        handle_error(raw.NVXGetSampeRateCount(self.device_handle, ctypes.byref(count)))
        return count

    @property
    def frequency_bandwidth(self):
        &#34;&#34;&#34;Get frequency bandwidth.

        Returns
        -------
        list of nvx.structs.FrequencyBandwidth
            Frequency bandwidths. See nvx.structs
        &#34;&#34;&#34;
        # TODO: ask how large the array should be (assuming self.eeg_count + GND)
        buffer_size = self.eeg_count + 1
        buffer_size_bytes = buffer_size * ctypes.sizeof(FrequencyBandwidth)
        buffer = (FrequencyBandwidth * buffer_size)()

        handle_error(raw.NVXGetFrequencyBandwidth(self.device_handle, buffer, buffer_size_bytes))
        
        result = [buffer[i] for i in range(buffer_size)]
        return result

    @property
    def _channel_states(self):
        &#34;&#34;&#34;Get enabled channels.
        This function is not recommended for external use. Consider using Device.get_eeg_channel_state or
        Device.get_aux_channel_state instead.

        Returns
        -------
        list of bool
            Channel states.

        See Also
        --------
        nvx.device.Device.get_eeg_channel_state
        nvx.device.Device.get_aux_channel_state
        &#34;&#34;&#34;
        buffer_size = self.eeg_count + self.aux_count
        buffer_size_bytes = buffer_size * ctypes.sizeof(ctypes.c_bool)
        buffer = (ctypes.c_bool * buffer_size)()

        handle_error(raw.NVXGetChannelsEnabled(self.device_handle, buffer, buffer_size_bytes))

        return buffer

    @_channel_states.setter
    def _channel_states(self, values):
        &#34;&#34;&#34;Set enabled channels
        This function is not recommended for external use. Consider using channel_states property instead.

        Warnings
        --------
        This function assumes that the size of passed array is correct. Otherwise, some bad things can happen.

        Parameters
        ----------
        values : a ctypes array of ctypes.c_bool of size count_eeg+count_aux
            values to set
        &#34;&#34;&#34;
        buffer_size = self.eeg_count + self.aux_count
        buffer_size_bytes = buffer_size * ctypes.sizeof(ctypes.c_bool)

        handle_error(raw.NVXSetChannelsEnabled(self.device_handle, values, buffer_size_bytes))

    @property
    def channel_states(self):
        &#34;&#34;&#34;Get a nice and user-friendly view into channel states.
        Returns channel states, that can be looked up either by name, or by an index.

        Returns
        -------
        nvx.channel_states_view.ChannelStatesView
            A view into channel states. See nvx.channel_states_view
        &#34;&#34;&#34;
        return ChannelStatesView(self)

    @property
    def pll(self):
        # TODO: verify that NVXGetPll return type is error code (assuming it is)
        pll = Pll()
        handle_error(raw.NVXGetPll(self.device_handle, ctypes.byref(pll)))
        return pll

    @pll.setter
    def pll(self, value):
        # TODO: verify that NVXSetPll return type is error code (assuming it is)
        handle_error(raw.NVXSetPll(self.device_handle, ctypes.byref(value)))

    def __del__(self):
        &#34;&#34;&#34;Destroy the device.
        On destruction, the device attempts to stop and close itself, but no error checking and/or recovery is
        performed.
        &#34;&#34;&#34;
        if self.is_running:
            raw.NVXStop(self.device_handle)
        raw.NVXClose(self.index)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="nvx.device.Device"><code class="flex name class">
<span>class <span class="ident">Device</span></span>
<span>(</span><span>index, buffer_time=1.0)</span>
</code></dt>
<dd>
<section class="desc"><p>A representation of a physical device connected to the system.
Constructor opens a hardware device for work.
Device is closed automatically when the object is deleted.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>index</code></strong> :&ensp;<code>int</code></dt>
<dd>device index in the system. Must be in range [0, nvx.get_count())</dd>
<dt><strong><code>buffer_time</code></strong></dt>
<dd>amount of time for which the samples will be kept in seconds</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Device:
    def __init__(self, index: int, buffer_time: float = 1.0):
        &#34;&#34;&#34;A representation of a physical device connected to the system.
        Constructor opens a hardware device for work.
        Device is closed automatically when the object is deleted.

        Parameters
        ----------
        index : int
            device index in the system. Must be in range [0, nvx.get_count())
        buffer_time
            amount of time for which the samples will be kept in seconds
        &#34;&#34;&#34;
        # Opening device -----------------------------------------------------------------------------------------------
        if 0 &lt;= index &lt; get_count():
            self.device_handle = raw.NVXOpen(index)
        else:
            raise ValueError(
                &#34;no device with index &#34; + str(index) + &#34; (only &#34; + str(get_count()) + &#34; devices detected)&#34;)

        if self.device_handle == 0:
            raise RuntimeError(&#34;Could not create a device: NVXOpen returned NULL&#34;)

        # This getter has side effects that are required for the device to work properly
        self.voltages

        # Data collecting ----------------------------------------------------------------------------------------------
        self._buffer_time = buffer_time
        self._buffer = None  # Created at start()
        self._collector_thread = Thread(target=self._collect)
        self._delay_tolerance = 0.01

        # Member variables ---------------------------------------------------------------------------------------------
        self._index = index
        self._is_running = False  # Not for external use. Use start(), stop(), or is_running property instead.
        self._active_shield_gain = 100

        # Data acquisition rate (hz). Not always the same as source_rate property.
        # Not for external use. Use rate property instead.
        self._rate = 10000

        # Set source rate to the maximum. Seems that this results in the least delay. Unneeded samples are discarded
        # during collection.
        s = self._settings
        s.rate = Rate.KHZ_100
        self._settings = s

    @property
    def index(self):
        &#34;&#34;&#34;Device&#39;s index in the system.&#34;&#34;&#34;
        return self._index

    @property
    def is_running(self):
        &#34;&#34;&#34;State of the data acquisition process.&#34;&#34;&#34;
        return self._is_running

    @property
    def version(self):
        &#34;&#34;&#34;Version info about NVX.

        Returns
        -------
        nvx.structs.Version
            NVX version info. See nvx.structs
        &#34;&#34;&#34;
        ver = Version()
        handle_error(raw.NVXGetVersion(self.device_handle, ctypes.byref(ver)))
        return ver

    # Settings and their properties ====================================================================================
    @property
    def _settings(self):
        &#34;&#34;&#34;Device acquisition settings.
        This property is for internal use. Struct Settings has 4 members, (mode, rate, adc_filter, decimation), of which
        mode, rate and decimation can be accessed via their own properties (acquisition_mode, rate/source_rate and
        decimation), and adc_filter is deprecated in the dll.

        Returns
        -------
        nvx.structs.Settings
            device settings. See nvx.structs
        &#34;&#34;&#34;
        result = Settings()
        handle_error(raw.NVXGetSettings(self.device_handle, ctypes.byref(result)))
        return result

    @_settings.setter
    def _settings(self, value):
        &#34;&#34;&#34;Set device acquisition settings
        This property is for internal use. Struct Settings has 4 members, (mode, rate, adc_filter, decimation), of which
        mode, rate and decimation can be accessed via their own properties (acquisition_mode, rate/source_rate and
        decimation), and adc_filter is deprecated in the DLL.

        Rate property affects nvx.structs.Property.rate as well as nvx.structs.Settings.rate.
        
        Parameters
        ----------
        value : nvx.structs.Settings
        &#34;&#34;&#34;
        handle_error(raw.NVXSetSettings(self.device_handle, ctypes.byref(value)))

    @property
    def acquisition_mode(self):
        return self._settings.mode

    @acquisition_mode.setter
    def acquisition_mode(self, value):
        s = self._settings
        s.mode = value
        self._settings = s

    @property
    def decimation(self):
        return self._settings.mode

    @decimation.setter
    def decimation(self, value):
        s = self._settings
        s.decimation = value
        self._settings = s

    # Properties and their properties ==================================================================================
    @property
    def _properties(self):
        &#34;&#34;&#34;Get device acquisition _properties.

        Returns
        -------
        nvx.structs.Property
            device property. See nvx.structs
        &#34;&#34;&#34;
        prop = Property()
        handle_error(raw.NVXGetProperty(self.device_handle, ctypes.byref(prop)))
        return prop

    @property
    def eeg_count(self):
        &#34;&#34;&#34;Get the count of EEG channels.&#34;&#34;&#34;
        return self._properties.count_eeg

    @property
    def aux_count(self):
        &#34;&#34;&#34;Get the count of AUX channels.&#34;&#34;&#34;
        return self._properties.count_aux

    @property
    def input_triggers_count(self):
        &#34;&#34;&#34;Get the count of input triggers.&#34;&#34;&#34;
        return self._properties.triggers_in

    @property
    def output_triggers_count(self):
        &#34;&#34;&#34;Get the count of output triggers.&#34;&#34;&#34;
        return self._properties.triggers_out

    @property
    def source_rate(self):
        &#34;&#34;&#34;Get device&#39;s actual pull rate.
        self._properties.rate is always the same as self._settings.rate, but presented as a float instead of enum.

        Returns
        -------
        int
            device&#39;s internal pull rate. Always one of (10000, 50000, 100000). Default is 10000.
        &#34;&#34;&#34;
        return int(self._properties.rate)

    @property
    def eeg_resolution(self):
        &#34;&#34;&#34;Get the EEG amplitude scale coefficients, in V/bit.

        Returns
        -------
        float
        &#34;&#34;&#34;
        return self._properties.resolution_eeg

    @property
    def aux_resolution(self):
        &#34;&#34;&#34;Get the AUX amplitude scale coefficients, in V/bit.

        Returns
        -------
        float
        &#34;&#34;&#34;
        return self._properties.resolution_aux

    @property
    def eeg_range(self):
        &#34;&#34;&#34;Get the EEG input range peak-peak, in V.

        Returns
        -------
        float
        &#34;&#34;&#34;
        return self._properties.range_eeg

    @property
    def aux_range(self):
        &#34;&#34;&#34;Get the AUX input range peak-peak, in V.

        Returns
        -------
        float
        &#34;&#34;&#34;
        return self._properties.range_aux

    # Adjusted rate property ===========================================================================================
    @property
    def rate(self):
        &#34;&#34;&#34;Device&#39;s pull rate.
        This is the rate at which the device will output values, and is equal to source_rate by default.
        Otherwise, it is usually lower, and some samples will be discarded to meet this rate.

        Returns
        -------
        int
            device&#39;s sample output rate in range [1, 100000] (samples/s).
        &#34;&#34;&#34;
        return self._rate

    @rate.setter
    def rate(self, value):
        &#34;&#34;&#34;Set device&#39;s pull rate.

        Parameters
        ----------
        value : int
            device&#39;s sample output rate in range [1, 100000] (samples/s).
        &#34;&#34;&#34;
        if value &lt;= 0:
            raise ValueError(&#34;sampling frequency too low: must not be less than 1, got &#34; + str(value))
        elif value &gt; 100000:
            raise ValueError(&#34;sampling frequency too high: must not be more than 100000, got &#34; + str(value))

        # Set sampling frequency
        self._rate = value

    # ==================================================================================================================

    def _new_buffer(self):
        &#34;&#34;&#34;Create a new internal buffer.
        Not recommended for external use.
        &#34;&#34;&#34;
        return RingBuffer(math.ceil(self.rate * self._buffer_time), dtype=object)

    def start(self):
        &#34;&#34;&#34;Start data acquisition.
        If data acquisition was already running, does nothing.
        &#34;&#34;&#34;
        if not self.is_running:
            self._buffer = self._new_buffer()
            handle_error(raw.NVXStart(self.device_handle))
            self._is_running = True
            self._collector_thread.start()

    def stop(self):
        &#34;&#34;&#34;Stop data acquisition.
        If data acquisition was not running, does nothing.
        &#34;&#34;&#34;
        if self.is_running:
            self._is_running = False
            self._collector_thread.join()
            handle_error(raw.NVXStop(self.device_handle))

    @property
    def delay_tolerance(self):
        &#34;&#34;&#34;Get device&#39;s delay tolerance.
        Delay tolerance represents time in seconds, how much the device is allowed to wait before attempting to pull a
        data sample. Even with this time, the collector thread will sleep only when it has collected all the samples
        that were available.

        Default time is 0.01 seconds, and can be set to 0 (although that might lead to inconsistent pull times due to
        thread locks fighting).

        Returns
        -------
        float
            Delay tolerance, seconds.
        &#34;&#34;&#34;
        return self._delay_tolerance

    @delay_tolerance.setter
    def delay_tolerance(self, value):
        &#34;&#34;&#34;Set a new delay tolerance.
        Delay tolerance represents time in seconds, how much the device is allowed to wait before attempting to pull a
        data sample. Even with this time, the collector thread will sleep only when it has collected all the samples
        that were available.

        Default time is 0.01 seconds. Delay tolerance is used in the collector thread, and thus cannot be set when the
        device is running.

        Warnings
        --------
        Setting delay_tolerance to 0 might lead to inconsistent pull times.

        Parameters
        ----------
        value : float
            Delay tolerance in seconds (must be not less than 0).

        Raises
        ------
        ValueError
            If the passed value is less than 0.
        RuntimeError
            If the device is currently running.
        &#34;&#34;&#34;
        if value &lt; 0:
            raise ValueError(&#34;delay_tolerance cannot be less than 0&#34;)

        if self.is_running:
            raise RuntimeError(&#34;delay_tolerance cannot be set when the device is running&#34;)
        self._delay_tolerance = value

    def _get_data(self):
        &#34;&#34;&#34;Get acquisition data.
        Returns a data sample or None, if there are no more samples generated.
        Not recommended for external use. Consider using Device.pull_chunk method instead.

        When the device is running, this class calls this function until there are no more samples to get.
        Otherwise, the internal buffer may overflow.

        Returns
        -------
        nvx.sample.Sample or None
            possible data sample. See sample.py
        &#34;&#34;&#34;
        buffer_size_bytes = self.eeg_count * 4 + self.aux_count * 4 + 8
        buffer = ctypes.cast(ctypes.create_string_buffer(buffer_size_bytes), ctypes.c_void_p)

        ret = raw.NVXGetData(self.device_handle, buffer, buffer_size_bytes)
        handle_error(ret)
        if ret == 0:  # no more data to return
            return None

        return Sample(buffer, self.eeg_count, self.aux_count)

    def _collect(self):
        &#34;&#34;&#34;Collect and process samples when running.
        Not recommended for external use.
        &#34;&#34;&#34;
        while self.is_running:
            # Get new sample (returns None if no samples left)
            sample = self._get_data()

            if sample is not None and self._process(sample):
                self._buffer.append(sample)
            if sample is None and self.delay_tolerance &gt; 0:
                time.sleep(self.delay_tolerance)

    def _process(self, sample):
        &#34;&#34;&#34;Process a sample (figure out if it should be discarded to keep user-specified rate).
        Returns True if a sample is to be accepted.
        Not recommended for external use.
        &#34;&#34;&#34;
        ratio = self.rate / self.source_rate

        cup0 = int(ratio * sample.counter)
        cup1 = int(ratio * (sample.counter+1))

        # if a cup was filled, accept sample
        return cup0 != cup1

    def pull_chunk(self):
        &#34;&#34;&#34;Pull all samples from the device.

        Returns
        -------
        nvx.ring_buffer.RingBuffer
            Requested samples. list can be empty, if no samples were generated since last call.
        &#34;&#34;&#34;
        # TODO: is this actually thread-safe?
        result, self._buffer = self._buffer, self._new_buffer()
        return result

    @property
    def _data_status(self):
        &#34;&#34;&#34;Get device acquisition data status.

        Returns
        -------
        nvx.structs.DataStatus
            device data status. See nvx.structs
        &#34;&#34;&#34;
        status = DataStatus()
        handle_error(raw.NVXGetDataStatus(self.device_handle, ctypes.byref(status)))
        return status

    @property
    def error_status(self):
        &#34;&#34;&#34;Get device acquisition error status.

        Returns
        -------
        nvx.structs.ErrorStatus
            device error status. See nvx.structs
        &#34;&#34;&#34;
        status = ErrorStatus()
        handle_error(raw.NVXGetErrorStatus(self.device_handle, ctypes.byref(status)))
        return status

    @property
    def source_sample_count(self):
        &#34;&#34;&#34;Returns how many samples were generated on the hardware device.
        Since Device implements rate downsampling, this number is equal or larger than the amount of samples passed to
        the device user.
        This value is the same as field &#39;samples&#39; in data_status and error status, and provided here for convenience.

        Returns
        -------
        int
            Samples count.
        &#34;&#34;&#34;
        return self._data_status.samples

    @property
    def trigger_states(self):
        &#34;&#34;&#34;Provides a view into device&#39;s trigger states

        Returns
        -------
        TriggerStatesView
            Triggers&#39; view. See trigger_states_view.py
        &#34;&#34;&#34;
        return TriggerStatesView(self)

    @property
    def aux_gain(self):
        &#34;&#34;&#34;Get AUX gain.
        While internally Gain is used as an enum, this function returns an int for convenience.

        Returns
        -------
        int
            gain value (1 or 5).

        See Also
        --------
        nvx.structs.Gain
        &#34;&#34;&#34;
        gain = Gain()
        handle_error(raw.NVXGetAuxGain(self.device_handle, ctypes.byref(gain)))

        if gain == Gain.GAIN_1:
            return 1
        return 5

    @aux_gain.setter
    def aux_gain(self, value):
        &#34;&#34;&#34;Set AUX gain.
        While internally Gain is used as an enum, this function accepts an int for convenience. That means that the only
        acceptable values for gain are 1 and 5.

        Raises
        ------
        ValueError
            if passed gain value is not 1 or 5.

        Parameters
        ----------
        value : int
            gain value.

        See Also
        --------
        nvx.structs.Gain
        &#34;&#34;&#34;
        gain = Gain()
        if value == 1:
            gain = Gain.GAIN_1
        elif value == 5:
            gain = Gain.GAIN_5
        else:
            raise ValueError(&#34;expected a gain value of either 1 or 5, got &#34; + str(value))
        handle_error(raw.NVXSetAuxGain(self.device_handle, gain))

    @property
    def power_save(self):
        &#34;&#34;&#34;Get power save mode.

        Returns
        -------
        bool
            True if power save mode is enabled, False otherwise.
        &#34;&#34;&#34;
        ps = PowerSave()
        handle_error(raw.NVXGetPowerSave(self.device_handle, ctypes.byref(ps)))
        if ps == PowerSave.DISABLE:
            return False
        return True

    @power_save.setter
    def power_save(self, value):
        &#34;&#34;&#34;Set power save mode.

        Parameters
        ----------
        value : bool
            True to enable power save, False to disable.
        &#34;&#34;&#34;
        ps = PowerSave.DISABLE
        if value:
            ps = PowerSave.ENABLE

        handle_error(raw.NVXSetPowerSave(self.device_handle, PowerSave(ps)))

    @property
    def impedance_data(self):
        &#34;&#34;&#34;Get impedance values for all EEG channels and ground in Ohm
        
        Notes
        -----
        - ~750 ms is required for measure impedance per 32 electrodes;
        - max impedance value ~ 300-500 kOhm;
        - impedance measure from 0 Ohm to 120 kOhm with accuracy +/- 15%;
        - works only in impedance mode;
        - ground electrode must be connected for impedance measure;
        - REF electrode (1-st electrode on 1-st module) must be connected for impedance measure;
        - if electrode is not connected, Impedance object will return None.
        
        Returns
        -------
        nvx.impedance.Impedance
            channels impedance. See nvx.impedance
        &#34;&#34;&#34;
        buffer_size = self.eeg_count + 1
        buffer_size_bytes = buffer_size * 4
        buffer = (ctypes.c_uint * buffer_size)()

        handle_error(raw.NVXImpedanceGetData(self.device_handle, buffer, buffer_size_bytes))

        return Impedance(buffer, self.eeg_count)

    @property
    def impedance_setup(self):
        &#34;&#34;&#34;Get setup for impedance mode.

        Returns
        -------
        nvx.structs.ImpedanceSetup
            impedance setup. See nvx.structs
        &#34;&#34;&#34;
        setup = ImpedanceSetup()
        handle_error(raw.NVXImpedanceGetSetup(self.device_handle, ctypes.byref(setup)))
        return setup

    @impedance_setup.setter
    def impedance_setup(self, setup):
        &#34;&#34;&#34;Set setup for impedance mode.

        Parameters
        ----------
        setup : nvx.structs.ImpedanceSetup
            impedance setup. See nvx.structs
        &#34;&#34;&#34;
        handle_error(raw.NVXImpedanceSetSetup(self.device_handle, ctypes.byref(setup)))

    @property
    def impedance_mode(self):
        &#34;&#34;&#34;Get current impedance mode.

        Returns
        -------
        nvx.structs.ImpedanceMode
            impedance mode. See nvx.structs
        &#34;&#34;&#34;
        impedance_mode = ImpedanceMode()
        handle_error(raw.NVXImpedanceGetMode(self.device_handle, ctypes.byref(impedance_mode)))
        return impedance_mode

    @impedance_mode.setter
    def impedance_mode(self, mode):
        &#34;&#34;&#34;Set current impedance mode.

        Parameters
        ----------
        mode : nvx.structs.ImpedanceMode
            impedance mode. See nvx.structs
        &#34;&#34;&#34;
        handle_error(raw.NVXImpedanceGetMode(self.device_handle, ctypes.byref(mode)))

    def set_electrodes(self, values):
        &#34;&#34;&#34;Directly set (control) electrodes states (LEDs and analog switches) in all modes.
        
        Notes
        -----
        - by calling this function, direct control of electrodes starts automatically;
        - to disable direct control of electrodes call set_electrodes_auto;
        - currently, you need to set all electrodes states at once;
        - To set electrodes colors it&#39;s recommended to use NVX_EL_LED_XXX (see globals.py) values.
        
        Parameters
        ----------
        values : a list-like container of objects, each convertible to ctypes.c_uint
            example - a list of int
        
        Warnings
        --------
        - During data acquisition due to switching supply current (i.e. LEDs), a ripple in analog power supply voltage
        appears. This leads to crosstalk to low level input signal and to distortion (and some pulsation) after
        switching supply current (i.e. LEDs);
        - in Impedance mode input analog switch is not accessible;
        - in Impedance mode it is not recommended to call this function very frequently;
        (&gt; few times per 1 sec) or to change (from previous state) too many electrodes, 
        because this will significantly increase impedance measure time (cycle) - see below;
        - After a successful call to this function the device will execute this command:
        ~ 50 ms per 32 electrodes states changes from previous state
        &#34;&#34;&#34;
        buffer_size = self.eeg_count + 1
        buffer_size_bytes = buffer_size * 4
        buffer = (ctypes.c_uint * buffer_size)()

        for i in range(0, buffer_size):
            buffer[i] = ctypes.c_uint(values[i])

        handle_error(raw.NVXSetElectrodes(self.device_handle, buffer, buffer_size_bytes))

    def set_electrodes_auto(self):
        &#34;&#34;&#34;Enable automatic LED control.
        If automatic LED control was disabled by the Device.set_electrodes function, it can be restored by calling this.
        &#34;&#34;&#34;
        handle_error(raw.NVXSetElectrodes(self.device_handle, None, 0))

    @property
    def impedance_scan_frequency(self):
        &#34;&#34;&#34;Get the impedance scanning frequency, in Hz.
        While internally frequency is used as an enum (nvx.structs.ScanFreq) packaged in
        a struct (nvx.structs.ImpedanceSettings), this function returns an int for convenience.

        Returns
        -------
        int
            Impedance scan frequency value (30 or 80 Hz). See also nvx.structs.ScanFreq
        &#34;&#34;&#34;
        imp_settings = ImpedanceSettings()
        handle_error(raw.NVXImpedanceGetSettings(self.device_handle, ctypes.byref(imp_settings)))
        scan_freq = imp_settings.scan_freq

        if scan_freq == ScanFreq.HZ_30:
            return 30
        return 80

    @impedance_scan_frequency.setter
    def impedance_scan_frequency(self, value):
        &#34;&#34;&#34;Set the impedance scanning frequency.
        While internally frequency is used as an enum (nvx.structs.ScanFreq) packaged in
        a struct (nvx.structs.ImpedanceSettings), this function accepts an int for convenience.

        Raises
        ------
        ValueError
            If passed gain value is not 30 or 80.

        Parameters
        ----------
        value : int
            Impedance scan frequency value value. See also nvx.structs.ScanFreq
        &#34;&#34;&#34;
        imp_settings = ImpedanceSettings()
        if value == 30:
            imp_settings.scan_freq = ScanFreq.HZ_30
        elif value == 80:
            imp_settings.scan_freq = ScanFreq.HZ_80
        else:
            raise ValueError(&#34;expected a frequency value of either 30 or 80, got &#34; + str(value))
        handle_error(raw.NVXImpedanceSetSettings(self.device_handle, ctypes.byref(imp_settings)))

    @property
    def voltages(self):
        &#34;&#34;&#34;Get voltages.

        Returns
        -------
        nvx.structs.Voltages
            voltages. See nvx.structs
        &#34;&#34;&#34;
        voltages = Voltages()
        handle_error(raw.NVXGetVoltages(self.device_handle, ctypes.byref(voltages)))
        return voltages

    @property
    def active_shield_gain(self):
        &#34;&#34;&#34;Get gain in ActiveShield mode.

        Returns
        -------
        int
            Gain value
        &#34;&#34;&#34;
        return self._active_shield_gain

    @active_shield_gain.setter
    def active_shield_gain(self, gain):
        &#34;&#34;&#34;Set gain in ActiveShield mode.
        
        Parameters
        ----------
        gain : int
            Impedance settings in range [1, 100]. Default gain is 100.
            
        Raises
        ------
        ValueError
            If gain is not in range [1, 100].
        &#34;&#34;&#34;
        if not 1 &lt;= gain &lt;= 100:
            raise ValueError(&#34;gain must be in range [1, 100], got &#34; + str(gain))

        handle_error(raw.NVXSetActiveShieldGain(self.device_handle, ctypes.c_uint(gain)))
        self._active_shield_gain = gain

    @property
    def polarization(self):
        &#34;&#34;&#34;Get polarization of the electrodes.

        Returns
        -------
        list of float
            Polarisation of electrodes.
        &#34;&#34;&#34;
        # TODO: ask how many electrodes there are (assuming self.eeg_count + GND)
        buffer_size = self.eeg_count + 1
        buffer_size_bytes = buffer_size * ctypes.sizeof(ctypes.c_double)
        buffer = (ctypes.c_double * buffer_size)()

        handle_error(raw.NVXSetElectrodes(self.device_handle, buffer, buffer_size_bytes))

        # Convert to a list of floats
        result = []
        for i in range(0, buffer_size):
            result.append(float(buffer[i]))

        return result

    @property
    def sample_rate_count(self):
        &#34;&#34;&#34;Get device sample rate count.

        Returns
        -------
        int
            Sample rate count.
        &#34;&#34;&#34;
        count = ctypes.c_uint()
        handle_error(raw.NVXGetSampeRateCount(self.device_handle, ctypes.byref(count)))
        return count

    @property
    def frequency_bandwidth(self):
        &#34;&#34;&#34;Get frequency bandwidth.

        Returns
        -------
        list of nvx.structs.FrequencyBandwidth
            Frequency bandwidths. See nvx.structs
        &#34;&#34;&#34;
        # TODO: ask how large the array should be (assuming self.eeg_count + GND)
        buffer_size = self.eeg_count + 1
        buffer_size_bytes = buffer_size * ctypes.sizeof(FrequencyBandwidth)
        buffer = (FrequencyBandwidth * buffer_size)()

        handle_error(raw.NVXGetFrequencyBandwidth(self.device_handle, buffer, buffer_size_bytes))
        
        result = [buffer[i] for i in range(buffer_size)]
        return result

    @property
    def _channel_states(self):
        &#34;&#34;&#34;Get enabled channels.
        This function is not recommended for external use. Consider using Device.get_eeg_channel_state or
        Device.get_aux_channel_state instead.

        Returns
        -------
        list of bool
            Channel states.

        See Also
        --------
        nvx.device.Device.get_eeg_channel_state
        nvx.device.Device.get_aux_channel_state
        &#34;&#34;&#34;
        buffer_size = self.eeg_count + self.aux_count
        buffer_size_bytes = buffer_size * ctypes.sizeof(ctypes.c_bool)
        buffer = (ctypes.c_bool * buffer_size)()

        handle_error(raw.NVXGetChannelsEnabled(self.device_handle, buffer, buffer_size_bytes))

        return buffer

    @_channel_states.setter
    def _channel_states(self, values):
        &#34;&#34;&#34;Set enabled channels
        This function is not recommended for external use. Consider using channel_states property instead.

        Warnings
        --------
        This function assumes that the size of passed array is correct. Otherwise, some bad things can happen.

        Parameters
        ----------
        values : a ctypes array of ctypes.c_bool of size count_eeg+count_aux
            values to set
        &#34;&#34;&#34;
        buffer_size = self.eeg_count + self.aux_count
        buffer_size_bytes = buffer_size * ctypes.sizeof(ctypes.c_bool)

        handle_error(raw.NVXSetChannelsEnabled(self.device_handle, values, buffer_size_bytes))

    @property
    def channel_states(self):
        &#34;&#34;&#34;Get a nice and user-friendly view into channel states.
        Returns channel states, that can be looked up either by name, or by an index.

        Returns
        -------
        nvx.channel_states_view.ChannelStatesView
            A view into channel states. See nvx.channel_states_view
        &#34;&#34;&#34;
        return ChannelStatesView(self)

    @property
    def pll(self):
        # TODO: verify that NVXGetPll return type is error code (assuming it is)
        pll = Pll()
        handle_error(raw.NVXGetPll(self.device_handle, ctypes.byref(pll)))
        return pll

    @pll.setter
    def pll(self, value):
        # TODO: verify that NVXSetPll return type is error code (assuming it is)
        handle_error(raw.NVXSetPll(self.device_handle, ctypes.byref(value)))

    def __del__(self):
        &#34;&#34;&#34;Destroy the device.
        On destruction, the device attempts to stop and close itself, but no error checking and/or recovery is
        performed.
        &#34;&#34;&#34;
        if self.is_running:
            raw.NVXStop(self.device_handle)
        raw.NVXClose(self.index)</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="nvx.device.Device.acquisition_mode"><code class="name">var <span class="ident">acquisition_mode</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def acquisition_mode(self):
    return self._settings.mode</code></pre>
</details>
</dd>
<dt id="nvx.device.Device.active_shield_gain"><code class="name">var <span class="ident">active_shield_gain</span></code></dt>
<dd>
<section class="desc"><p>Get gain in ActiveShield mode.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>Gain value</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def active_shield_gain(self):
    &#34;&#34;&#34;Get gain in ActiveShield mode.

    Returns
    -------
    int
        Gain value
    &#34;&#34;&#34;
    return self._active_shield_gain</code></pre>
</details>
</dd>
<dt id="nvx.device.Device.aux_count"><code class="name">var <span class="ident">aux_count</span></code></dt>
<dd>
<section class="desc"><p>Get the count of AUX channels.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def aux_count(self):
    &#34;&#34;&#34;Get the count of AUX channels.&#34;&#34;&#34;
    return self._properties.count_aux</code></pre>
</details>
</dd>
<dt id="nvx.device.Device.aux_gain"><code class="name">var <span class="ident">aux_gain</span></code></dt>
<dd>
<section class="desc"><p>Get AUX gain.
While internally Gain is used as an enum, this function returns an int for convenience.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>gain value (1 or 5).</dd>
</dl>
<h2 id="see-also">See Also</h2>
<p><a title="nvx.structs.Gain" href="structs.html#nvx.structs.Gain"><code>Gain</code></a></p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def aux_gain(self):
    &#34;&#34;&#34;Get AUX gain.
    While internally Gain is used as an enum, this function returns an int for convenience.

    Returns
    -------
    int
        gain value (1 or 5).

    See Also
    --------
    nvx.structs.Gain
    &#34;&#34;&#34;
    gain = Gain()
    handle_error(raw.NVXGetAuxGain(self.device_handle, ctypes.byref(gain)))

    if gain == Gain.GAIN_1:
        return 1
    return 5</code></pre>
</details>
</dd>
<dt id="nvx.device.Device.aux_range"><code class="name">var <span class="ident">aux_range</span></code></dt>
<dd>
<section class="desc"><p>Get the AUX input range peak-peak, in V.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def aux_range(self):
    &#34;&#34;&#34;Get the AUX input range peak-peak, in V.

    Returns
    -------
    float
    &#34;&#34;&#34;
    return self._properties.range_aux</code></pre>
</details>
</dd>
<dt id="nvx.device.Device.aux_resolution"><code class="name">var <span class="ident">aux_resolution</span></code></dt>
<dd>
<section class="desc"><p>Get the AUX amplitude scale coefficients, in V/bit.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def aux_resolution(self):
    &#34;&#34;&#34;Get the AUX amplitude scale coefficients, in V/bit.

    Returns
    -------
    float
    &#34;&#34;&#34;
    return self._properties.resolution_aux</code></pre>
</details>
</dd>
<dt id="nvx.device.Device.channel_states"><code class="name">var <span class="ident">channel_states</span></code></dt>
<dd>
<section class="desc"><p>Get a nice and user-friendly view into channel states.
Returns channel states, that can be looked up either by name, or by an index.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><a title="nvx.channel_states_view.ChannelStatesView" href="channel_states_view.html#nvx.channel_states_view.ChannelStatesView"><code>ChannelStatesView</code></a></dt>
<dd>A view into channel states. See nvx.channel_states_view</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def channel_states(self):
    &#34;&#34;&#34;Get a nice and user-friendly view into channel states.
    Returns channel states, that can be looked up either by name, or by an index.

    Returns
    -------
    nvx.channel_states_view.ChannelStatesView
        A view into channel states. See nvx.channel_states_view
    &#34;&#34;&#34;
    return ChannelStatesView(self)</code></pre>
</details>
</dd>
<dt id="nvx.device.Device.decimation"><code class="name">var <span class="ident">decimation</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def decimation(self):
    return self._settings.mode</code></pre>
</details>
</dd>
<dt id="nvx.device.Device.delay_tolerance"><code class="name">var <span class="ident">delay_tolerance</span></code></dt>
<dd>
<section class="desc"><p>Get device's delay tolerance.
Delay tolerance represents time in seconds, how much the device is allowed to wait before attempting to pull a
data sample. Even with this time, the collector thread will sleep only when it has collected all the samples
that were available.</p>
<p>Default time is 0.01 seconds, and can be set to 0 (although that might lead to inconsistent pull times due to
thread locks fighting).</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>Delay tolerance, seconds.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def delay_tolerance(self):
    &#34;&#34;&#34;Get device&#39;s delay tolerance.
    Delay tolerance represents time in seconds, how much the device is allowed to wait before attempting to pull a
    data sample. Even with this time, the collector thread will sleep only when it has collected all the samples
    that were available.

    Default time is 0.01 seconds, and can be set to 0 (although that might lead to inconsistent pull times due to
    thread locks fighting).

    Returns
    -------
    float
        Delay tolerance, seconds.
    &#34;&#34;&#34;
    return self._delay_tolerance</code></pre>
</details>
</dd>
<dt id="nvx.device.Device.eeg_count"><code class="name">var <span class="ident">eeg_count</span></code></dt>
<dd>
<section class="desc"><p>Get the count of EEG channels.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def eeg_count(self):
    &#34;&#34;&#34;Get the count of EEG channels.&#34;&#34;&#34;
    return self._properties.count_eeg</code></pre>
</details>
</dd>
<dt id="nvx.device.Device.eeg_range"><code class="name">var <span class="ident">eeg_range</span></code></dt>
<dd>
<section class="desc"><p>Get the EEG input range peak-peak, in V.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def eeg_range(self):
    &#34;&#34;&#34;Get the EEG input range peak-peak, in V.

    Returns
    -------
    float
    &#34;&#34;&#34;
    return self._properties.range_eeg</code></pre>
</details>
</dd>
<dt id="nvx.device.Device.eeg_resolution"><code class="name">var <span class="ident">eeg_resolution</span></code></dt>
<dd>
<section class="desc"><p>Get the EEG amplitude scale coefficients, in V/bit.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def eeg_resolution(self):
    &#34;&#34;&#34;Get the EEG amplitude scale coefficients, in V/bit.

    Returns
    -------
    float
    &#34;&#34;&#34;
    return self._properties.resolution_eeg</code></pre>
</details>
</dd>
<dt id="nvx.device.Device.error_status"><code class="name">var <span class="ident">error_status</span></code></dt>
<dd>
<section class="desc"><p>Get device acquisition error status.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><a title="nvx.structs.ErrorStatus" href="structs.html#nvx.structs.ErrorStatus"><code>ErrorStatus</code></a></dt>
<dd>device error status. See nvx.structs</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def error_status(self):
    &#34;&#34;&#34;Get device acquisition error status.

    Returns
    -------
    nvx.structs.ErrorStatus
        device error status. See nvx.structs
    &#34;&#34;&#34;
    status = ErrorStatus()
    handle_error(raw.NVXGetErrorStatus(self.device_handle, ctypes.byref(status)))
    return status</code></pre>
</details>
</dd>
<dt id="nvx.device.Device.frequency_bandwidth"><code class="name">var <span class="ident">frequency_bandwidth</span></code></dt>
<dd>
<section class="desc"><p>Get frequency bandwidth.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code> of <a title="nvx.structs.FrequencyBandwidth" href="structs.html#nvx.structs.FrequencyBandwidth"><code>FrequencyBandwidth</code></a></dt>
<dd>Frequency bandwidths. See nvx.structs</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def frequency_bandwidth(self):
    &#34;&#34;&#34;Get frequency bandwidth.

    Returns
    -------
    list of nvx.structs.FrequencyBandwidth
        Frequency bandwidths. See nvx.structs
    &#34;&#34;&#34;
    # TODO: ask how large the array should be (assuming self.eeg_count + GND)
    buffer_size = self.eeg_count + 1
    buffer_size_bytes = buffer_size * ctypes.sizeof(FrequencyBandwidth)
    buffer = (FrequencyBandwidth * buffer_size)()

    handle_error(raw.NVXGetFrequencyBandwidth(self.device_handle, buffer, buffer_size_bytes))
    
    result = [buffer[i] for i in range(buffer_size)]
    return result</code></pre>
</details>
</dd>
<dt id="nvx.device.Device.impedance_data"><code class="name">var <span class="ident">impedance_data</span></code></dt>
<dd>
<section class="desc"><p>Get impedance values for all EEG channels and ground in Ohm</p>
<h2 id="notes">Notes</h2>
<ul>
<li>~750 ms is required for measure impedance per 32 electrodes;</li>
<li>max impedance value ~ 300-500 kOhm;</li>
<li>impedance measure from 0 Ohm to 120 kOhm with accuracy +/- 15%;</li>
<li>works only in impedance mode;</li>
<li>ground electrode must be connected for impedance measure;</li>
<li>REF electrode (1-st electrode on 1-st module) must be connected for impedance measure;</li>
<li>if electrode is not connected, Impedance object will return None.</li>
</ul>
<h2 id="returns">Returns</h2>
<dl>
<dt><a title="nvx.impedance.Impedance" href="impedance.html#nvx.impedance.Impedance"><code>Impedance</code></a></dt>
<dd>channels impedance. See nvx.impedance</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def impedance_data(self):
    &#34;&#34;&#34;Get impedance values for all EEG channels and ground in Ohm
    
    Notes
    -----
    - ~750 ms is required for measure impedance per 32 electrodes;
    - max impedance value ~ 300-500 kOhm;
    - impedance measure from 0 Ohm to 120 kOhm with accuracy +/- 15%;
    - works only in impedance mode;
    - ground electrode must be connected for impedance measure;
    - REF electrode (1-st electrode on 1-st module) must be connected for impedance measure;
    - if electrode is not connected, Impedance object will return None.
    
    Returns
    -------
    nvx.impedance.Impedance
        channels impedance. See nvx.impedance
    &#34;&#34;&#34;
    buffer_size = self.eeg_count + 1
    buffer_size_bytes = buffer_size * 4
    buffer = (ctypes.c_uint * buffer_size)()

    handle_error(raw.NVXImpedanceGetData(self.device_handle, buffer, buffer_size_bytes))

    return Impedance(buffer, self.eeg_count)</code></pre>
</details>
</dd>
<dt id="nvx.device.Device.impedance_mode"><code class="name">var <span class="ident">impedance_mode</span></code></dt>
<dd>
<section class="desc"><p>Get current impedance mode.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><a title="nvx.structs.ImpedanceMode" href="structs.html#nvx.structs.ImpedanceMode"><code>ImpedanceMode</code></a></dt>
<dd>impedance mode. See nvx.structs</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def impedance_mode(self):
    &#34;&#34;&#34;Get current impedance mode.

    Returns
    -------
    nvx.structs.ImpedanceMode
        impedance mode. See nvx.structs
    &#34;&#34;&#34;
    impedance_mode = ImpedanceMode()
    handle_error(raw.NVXImpedanceGetMode(self.device_handle, ctypes.byref(impedance_mode)))
    return impedance_mode</code></pre>
</details>
</dd>
<dt id="nvx.device.Device.impedance_scan_frequency"><code class="name">var <span class="ident">impedance_scan_frequency</span></code></dt>
<dd>
<section class="desc"><p>Get the impedance scanning frequency, in Hz.
While internally frequency is used as an enum (nvx.structs.ScanFreq) packaged in
a struct (nvx.structs.ImpedanceSettings), this function returns an int for convenience.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>Impedance scan frequency value (30 or 80 Hz). See also nvx.structs.ScanFreq</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def impedance_scan_frequency(self):
    &#34;&#34;&#34;Get the impedance scanning frequency, in Hz.
    While internally frequency is used as an enum (nvx.structs.ScanFreq) packaged in
    a struct (nvx.structs.ImpedanceSettings), this function returns an int for convenience.

    Returns
    -------
    int
        Impedance scan frequency value (30 or 80 Hz). See also nvx.structs.ScanFreq
    &#34;&#34;&#34;
    imp_settings = ImpedanceSettings()
    handle_error(raw.NVXImpedanceGetSettings(self.device_handle, ctypes.byref(imp_settings)))
    scan_freq = imp_settings.scan_freq

    if scan_freq == ScanFreq.HZ_30:
        return 30
    return 80</code></pre>
</details>
</dd>
<dt id="nvx.device.Device.impedance_setup"><code class="name">var <span class="ident">impedance_setup</span></code></dt>
<dd>
<section class="desc"><p>Get setup for impedance mode.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><a title="nvx.structs.ImpedanceSetup" href="structs.html#nvx.structs.ImpedanceSetup"><code>ImpedanceSetup</code></a></dt>
<dd>impedance setup. See nvx.structs</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def impedance_setup(self):
    &#34;&#34;&#34;Get setup for impedance mode.

    Returns
    -------
    nvx.structs.ImpedanceSetup
        impedance setup. See nvx.structs
    &#34;&#34;&#34;
    setup = ImpedanceSetup()
    handle_error(raw.NVXImpedanceGetSetup(self.device_handle, ctypes.byref(setup)))
    return setup</code></pre>
</details>
</dd>
<dt id="nvx.device.Device.index"><code class="name">var <span class="ident">index</span></code></dt>
<dd>
<section class="desc"><p>Device's index in the system.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def index(self):
    &#34;&#34;&#34;Device&#39;s index in the system.&#34;&#34;&#34;
    return self._index</code></pre>
</details>
</dd>
<dt id="nvx.device.Device.input_triggers_count"><code class="name">var <span class="ident">input_triggers_count</span></code></dt>
<dd>
<section class="desc"><p>Get the count of input triggers.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def input_triggers_count(self):
    &#34;&#34;&#34;Get the count of input triggers.&#34;&#34;&#34;
    return self._properties.triggers_in</code></pre>
</details>
</dd>
<dt id="nvx.device.Device.is_running"><code class="name">var <span class="ident">is_running</span></code></dt>
<dd>
<section class="desc"><p>State of the data acquisition process.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def is_running(self):
    &#34;&#34;&#34;State of the data acquisition process.&#34;&#34;&#34;
    return self._is_running</code></pre>
</details>
</dd>
<dt id="nvx.device.Device.output_triggers_count"><code class="name">var <span class="ident">output_triggers_count</span></code></dt>
<dd>
<section class="desc"><p>Get the count of output triggers.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def output_triggers_count(self):
    &#34;&#34;&#34;Get the count of output triggers.&#34;&#34;&#34;
    return self._properties.triggers_out</code></pre>
</details>
</dd>
<dt id="nvx.device.Device.pll"><code class="name">var <span class="ident">pll</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def pll(self):
    # TODO: verify that NVXGetPll return type is error code (assuming it is)
    pll = Pll()
    handle_error(raw.NVXGetPll(self.device_handle, ctypes.byref(pll)))
    return pll</code></pre>
</details>
</dd>
<dt id="nvx.device.Device.polarization"><code class="name">var <span class="ident">polarization</span></code></dt>
<dd>
<section class="desc"><p>Get polarization of the electrodes.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code> of <code>float</code></dt>
<dd>Polarisation of electrodes.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def polarization(self):
    &#34;&#34;&#34;Get polarization of the electrodes.

    Returns
    -------
    list of float
        Polarisation of electrodes.
    &#34;&#34;&#34;
    # TODO: ask how many electrodes there are (assuming self.eeg_count + GND)
    buffer_size = self.eeg_count + 1
    buffer_size_bytes = buffer_size * ctypes.sizeof(ctypes.c_double)
    buffer = (ctypes.c_double * buffer_size)()

    handle_error(raw.NVXSetElectrodes(self.device_handle, buffer, buffer_size_bytes))

    # Convert to a list of floats
    result = []
    for i in range(0, buffer_size):
        result.append(float(buffer[i]))

    return result</code></pre>
</details>
</dd>
<dt id="nvx.device.Device.power_save"><code class="name">var <span class="ident">power_save</span></code></dt>
<dd>
<section class="desc"><p>Get power save mode.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>True if power save mode is enabled, False otherwise.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def power_save(self):
    &#34;&#34;&#34;Get power save mode.

    Returns
    -------
    bool
        True if power save mode is enabled, False otherwise.
    &#34;&#34;&#34;
    ps = PowerSave()
    handle_error(raw.NVXGetPowerSave(self.device_handle, ctypes.byref(ps)))
    if ps == PowerSave.DISABLE:
        return False
    return True</code></pre>
</details>
</dd>
<dt id="nvx.device.Device.rate"><code class="name">var <span class="ident">rate</span></code></dt>
<dd>
<section class="desc"><p>Device's pull rate.
This is the rate at which the device will output values, and is equal to source_rate by default.
Otherwise, it is usually lower, and some samples will be discarded to meet this rate.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>device's sample output rate in range [1, 100000] (samples/s).</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def rate(self):
    &#34;&#34;&#34;Device&#39;s pull rate.
    This is the rate at which the device will output values, and is equal to source_rate by default.
    Otherwise, it is usually lower, and some samples will be discarded to meet this rate.

    Returns
    -------
    int
        device&#39;s sample output rate in range [1, 100000] (samples/s).
    &#34;&#34;&#34;
    return self._rate</code></pre>
</details>
</dd>
<dt id="nvx.device.Device.sample_rate_count"><code class="name">var <span class="ident">sample_rate_count</span></code></dt>
<dd>
<section class="desc"><p>Get device sample rate count.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>Sample rate count.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def sample_rate_count(self):
    &#34;&#34;&#34;Get device sample rate count.

    Returns
    -------
    int
        Sample rate count.
    &#34;&#34;&#34;
    count = ctypes.c_uint()
    handle_error(raw.NVXGetSampeRateCount(self.device_handle, ctypes.byref(count)))
    return count</code></pre>
</details>
</dd>
<dt id="nvx.device.Device.source_rate"><code class="name">var <span class="ident">source_rate</span></code></dt>
<dd>
<section class="desc"><p>Get device's actual pull rate.
self._properties.rate is always the same as self._settings.rate, but presented as a float instead of enum.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>device's internal pull rate. Always one of (10000, 50000, 100000). Default is 10000.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def source_rate(self):
    &#34;&#34;&#34;Get device&#39;s actual pull rate.
    self._properties.rate is always the same as self._settings.rate, but presented as a float instead of enum.

    Returns
    -------
    int
        device&#39;s internal pull rate. Always one of (10000, 50000, 100000). Default is 10000.
    &#34;&#34;&#34;
    return int(self._properties.rate)</code></pre>
</details>
</dd>
<dt id="nvx.device.Device.source_sample_count"><code class="name">var <span class="ident">source_sample_count</span></code></dt>
<dd>
<section class="desc"><p>Returns how many samples were generated on the hardware device.
Since Device implements rate downsampling, this number is equal or larger than the amount of samples passed to
the device user.
This value is the same as field 'samples' in data_status and error status, and provided here for convenience.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>Samples count.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def source_sample_count(self):
    &#34;&#34;&#34;Returns how many samples were generated on the hardware device.
    Since Device implements rate downsampling, this number is equal or larger than the amount of samples passed to
    the device user.
    This value is the same as field &#39;samples&#39; in data_status and error status, and provided here for convenience.

    Returns
    -------
    int
        Samples count.
    &#34;&#34;&#34;
    return self._data_status.samples</code></pre>
</details>
</dd>
<dt id="nvx.device.Device.trigger_states"><code class="name">var <span class="ident">trigger_states</span></code></dt>
<dd>
<section class="desc"><p>Provides a view into device's trigger states</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>TriggerStatesView</code></dt>
<dd>Triggers' view. See trigger_states_view.py</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def trigger_states(self):
    &#34;&#34;&#34;Provides a view into device&#39;s trigger states

    Returns
    -------
    TriggerStatesView
        Triggers&#39; view. See trigger_states_view.py
    &#34;&#34;&#34;
    return TriggerStatesView(self)</code></pre>
</details>
</dd>
<dt id="nvx.device.Device.version"><code class="name">var <span class="ident">version</span></code></dt>
<dd>
<section class="desc"><p>Version info about NVX.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><a title="nvx.structs.Version" href="structs.html#nvx.structs.Version"><code>Version</code></a></dt>
<dd>NVX version info. See nvx.structs</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def version(self):
    &#34;&#34;&#34;Version info about NVX.

    Returns
    -------
    nvx.structs.Version
        NVX version info. See nvx.structs
    &#34;&#34;&#34;
    ver = Version()
    handle_error(raw.NVXGetVersion(self.device_handle, ctypes.byref(ver)))
    return ver</code></pre>
</details>
</dd>
<dt id="nvx.device.Device.voltages"><code class="name">var <span class="ident">voltages</span></code></dt>
<dd>
<section class="desc"><p>Get voltages.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><a title="nvx.structs.Voltages" href="structs.html#nvx.structs.Voltages"><code>Voltages</code></a></dt>
<dd>voltages. See nvx.structs</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def voltages(self):
    &#34;&#34;&#34;Get voltages.

    Returns
    -------
    nvx.structs.Voltages
        voltages. See nvx.structs
    &#34;&#34;&#34;
    voltages = Voltages()
    handle_error(raw.NVXGetVoltages(self.device_handle, ctypes.byref(voltages)))
    return voltages</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="nvx.device.Device.pull_chunk"><code class="name flex">
<span>def <span class="ident">pull_chunk</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Pull all samples from the device.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><a title="nvx.ring_buffer.RingBuffer" href="ring_buffer.html#nvx.ring_buffer.RingBuffer"><code>RingBuffer</code></a></dt>
<dd>Requested samples. list can be empty, if no samples were generated since last call.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pull_chunk(self):
    &#34;&#34;&#34;Pull all samples from the device.

    Returns
    -------
    nvx.ring_buffer.RingBuffer
        Requested samples. list can be empty, if no samples were generated since last call.
    &#34;&#34;&#34;
    # TODO: is this actually thread-safe?
    result, self._buffer = self._buffer, self._new_buffer()
    return result</code></pre>
</details>
</dd>
<dt id="nvx.device.Device.set_electrodes"><code class="name flex">
<span>def <span class="ident">set_electrodes</span></span>(<span>self, values)</span>
</code></dt>
<dd>
<section class="desc"><p>Directly set (control) electrodes states (LEDs and analog switches) in all modes.</p>
<h2 id="notes">Notes</h2>
<ul>
<li>by calling this function, direct control of electrodes starts automatically;</li>
<li>to disable direct control of electrodes call set_electrodes_auto;</li>
<li>currently, you need to set all electrodes states at once;</li>
<li>To set electrodes colors it's recommended to use NVX_EL_LED_XXX (see globals.py) values.</li>
</ul>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>values</code></strong> :&ensp;<code>a</code> <code>list</code>-<code>like</code> <code>container</code> of <code>objects</code>, <code>each</code> <code>convertible</code> <code>to</code> <code>ctypes.c_uint</code></dt>
<dd>example - a list of int</dd>
</dl>
<h2 id="warnings">Warnings</h2>
<ul>
<li>During data acquisition due to switching supply current (i.e. LEDs), a ripple in analog power supply voltage
appears. This leads to crosstalk to low level input signal and to distortion (and some pulsation) after
switching supply current (i.e. LEDs);</li>
<li>in Impedance mode input analog switch is not accessible;</li>
<li>in Impedance mode it is not recommended to call this function very frequently;
(&gt; few times per 1 sec) or to change (from previous state) too many electrodes,
because this will significantly increase impedance measure time (cycle) - see below;</li>
<li>After a successful call to this function the device will execute this command:
~ 50 ms per 32 electrodes states changes from previous state</li>
</ul></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_electrodes(self, values):
    &#34;&#34;&#34;Directly set (control) electrodes states (LEDs and analog switches) in all modes.
    
    Notes
    -----
    - by calling this function, direct control of electrodes starts automatically;
    - to disable direct control of electrodes call set_electrodes_auto;
    - currently, you need to set all electrodes states at once;
    - To set electrodes colors it&#39;s recommended to use NVX_EL_LED_XXX (see globals.py) values.
    
    Parameters
    ----------
    values : a list-like container of objects, each convertible to ctypes.c_uint
        example - a list of int
    
    Warnings
    --------
    - During data acquisition due to switching supply current (i.e. LEDs), a ripple in analog power supply voltage
    appears. This leads to crosstalk to low level input signal and to distortion (and some pulsation) after
    switching supply current (i.e. LEDs);
    - in Impedance mode input analog switch is not accessible;
    - in Impedance mode it is not recommended to call this function very frequently;
    (&gt; few times per 1 sec) or to change (from previous state) too many electrodes, 
    because this will significantly increase impedance measure time (cycle) - see below;
    - After a successful call to this function the device will execute this command:
    ~ 50 ms per 32 electrodes states changes from previous state
    &#34;&#34;&#34;
    buffer_size = self.eeg_count + 1
    buffer_size_bytes = buffer_size * 4
    buffer = (ctypes.c_uint * buffer_size)()

    for i in range(0, buffer_size):
        buffer[i] = ctypes.c_uint(values[i])

    handle_error(raw.NVXSetElectrodes(self.device_handle, buffer, buffer_size_bytes))</code></pre>
</details>
</dd>
<dt id="nvx.device.Device.set_electrodes_auto"><code class="name flex">
<span>def <span class="ident">set_electrodes_auto</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Enable automatic LED control.
If automatic LED control was disabled by the Device.set_electrodes function, it can be restored by calling this.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_electrodes_auto(self):
    &#34;&#34;&#34;Enable automatic LED control.
    If automatic LED control was disabled by the Device.set_electrodes function, it can be restored by calling this.
    &#34;&#34;&#34;
    handle_error(raw.NVXSetElectrodes(self.device_handle, None, 0))</code></pre>
</details>
</dd>
<dt id="nvx.device.Device.start"><code class="name flex">
<span>def <span class="ident">start</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Start data acquisition.
If data acquisition was already running, does nothing.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def start(self):
    &#34;&#34;&#34;Start data acquisition.
    If data acquisition was already running, does nothing.
    &#34;&#34;&#34;
    if not self.is_running:
        self._buffer = self._new_buffer()
        handle_error(raw.NVXStart(self.device_handle))
        self._is_running = True
        self._collector_thread.start()</code></pre>
</details>
</dd>
<dt id="nvx.device.Device.stop"><code class="name flex">
<span>def <span class="ident">stop</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Stop data acquisition.
If data acquisition was not running, does nothing.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stop(self):
    &#34;&#34;&#34;Stop data acquisition.
    If data acquisition was not running, does nothing.
    &#34;&#34;&#34;
    if self.is_running:
        self._is_running = False
        self._collector_thread.join()
        handle_error(raw.NVXStop(self.device_handle))</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="nvx" href="index.html">nvx</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="nvx.device.Device" href="#nvx.device.Device">Device</a></code></h4>
<ul class="">
<li><code><a title="nvx.device.Device.acquisition_mode" href="#nvx.device.Device.acquisition_mode">acquisition_mode</a></code></li>
<li><code><a title="nvx.device.Device.active_shield_gain" href="#nvx.device.Device.active_shield_gain">active_shield_gain</a></code></li>
<li><code><a title="nvx.device.Device.aux_count" href="#nvx.device.Device.aux_count">aux_count</a></code></li>
<li><code><a title="nvx.device.Device.aux_gain" href="#nvx.device.Device.aux_gain">aux_gain</a></code></li>
<li><code><a title="nvx.device.Device.aux_range" href="#nvx.device.Device.aux_range">aux_range</a></code></li>
<li><code><a title="nvx.device.Device.aux_resolution" href="#nvx.device.Device.aux_resolution">aux_resolution</a></code></li>
<li><code><a title="nvx.device.Device.channel_states" href="#nvx.device.Device.channel_states">channel_states</a></code></li>
<li><code><a title="nvx.device.Device.decimation" href="#nvx.device.Device.decimation">decimation</a></code></li>
<li><code><a title="nvx.device.Device.delay_tolerance" href="#nvx.device.Device.delay_tolerance">delay_tolerance</a></code></li>
<li><code><a title="nvx.device.Device.eeg_count" href="#nvx.device.Device.eeg_count">eeg_count</a></code></li>
<li><code><a title="nvx.device.Device.eeg_range" href="#nvx.device.Device.eeg_range">eeg_range</a></code></li>
<li><code><a title="nvx.device.Device.eeg_resolution" href="#nvx.device.Device.eeg_resolution">eeg_resolution</a></code></li>
<li><code><a title="nvx.device.Device.error_status" href="#nvx.device.Device.error_status">error_status</a></code></li>
<li><code><a title="nvx.device.Device.frequency_bandwidth" href="#nvx.device.Device.frequency_bandwidth">frequency_bandwidth</a></code></li>
<li><code><a title="nvx.device.Device.impedance_data" href="#nvx.device.Device.impedance_data">impedance_data</a></code></li>
<li><code><a title="nvx.device.Device.impedance_mode" href="#nvx.device.Device.impedance_mode">impedance_mode</a></code></li>
<li><code><a title="nvx.device.Device.impedance_scan_frequency" href="#nvx.device.Device.impedance_scan_frequency">impedance_scan_frequency</a></code></li>
<li><code><a title="nvx.device.Device.impedance_setup" href="#nvx.device.Device.impedance_setup">impedance_setup</a></code></li>
<li><code><a title="nvx.device.Device.index" href="#nvx.device.Device.index">index</a></code></li>
<li><code><a title="nvx.device.Device.input_triggers_count" href="#nvx.device.Device.input_triggers_count">input_triggers_count</a></code></li>
<li><code><a title="nvx.device.Device.is_running" href="#nvx.device.Device.is_running">is_running</a></code></li>
<li><code><a title="nvx.device.Device.output_triggers_count" href="#nvx.device.Device.output_triggers_count">output_triggers_count</a></code></li>
<li><code><a title="nvx.device.Device.pll" href="#nvx.device.Device.pll">pll</a></code></li>
<li><code><a title="nvx.device.Device.polarization" href="#nvx.device.Device.polarization">polarization</a></code></li>
<li><code><a title="nvx.device.Device.power_save" href="#nvx.device.Device.power_save">power_save</a></code></li>
<li><code><a title="nvx.device.Device.pull_chunk" href="#nvx.device.Device.pull_chunk">pull_chunk</a></code></li>
<li><code><a title="nvx.device.Device.rate" href="#nvx.device.Device.rate">rate</a></code></li>
<li><code><a title="nvx.device.Device.sample_rate_count" href="#nvx.device.Device.sample_rate_count">sample_rate_count</a></code></li>
<li><code><a title="nvx.device.Device.set_electrodes" href="#nvx.device.Device.set_electrodes">set_electrodes</a></code></li>
<li><code><a title="nvx.device.Device.set_electrodes_auto" href="#nvx.device.Device.set_electrodes_auto">set_electrodes_auto</a></code></li>
<li><code><a title="nvx.device.Device.source_rate" href="#nvx.device.Device.source_rate">source_rate</a></code></li>
<li><code><a title="nvx.device.Device.source_sample_count" href="#nvx.device.Device.source_sample_count">source_sample_count</a></code></li>
<li><code><a title="nvx.device.Device.start" href="#nvx.device.Device.start">start</a></code></li>
<li><code><a title="nvx.device.Device.stop" href="#nvx.device.Device.stop">stop</a></code></li>
<li><code><a title="nvx.device.Device.trigger_states" href="#nvx.device.Device.trigger_states">trigger_states</a></code></li>
<li><code><a title="nvx.device.Device.version" href="#nvx.device.Device.version">version</a></code></li>
<li><code><a title="nvx.device.Device.voltages" href="#nvx.device.Device.voltages">voltages</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.7.2</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>